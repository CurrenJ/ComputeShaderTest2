// Each #kernel tells which function to compile; you can have many kernels
// kernel 1
#pragma kernel UpdateAgents
uint width;
uint height;
uint numAgents;
float moveSpeed;
float turnFactor;
float decayFactor;
float diffuseFactor;
float deltaTime;
float time;
int3 redHome;
int3 greenHome;
int3 blueHome;

float4 teamColorA;
float4 teamColorB;
float4 teamColorC;
float4 bgColor;

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

float4 ColorLerp(float4 t){
	// Midnight
    float4 a = float4(0.388235294, 0.11372549, 0.462745098, 1.0);
	// Magenta Haze
	float4 b = float4(0.619607843, 0.278431373, 0.439215686, 1.0);
	// White
	float4 c = float4(0.984313725, 0.984313725, 0.984313725, 1.0);

	// Background Color
	float bg = float4(0.180392157, 0.145098039, 0.196078431, 1.0);

    // float4 a = float4(0.776, 0.784, 0.984, 1);
    // float4 b = float4(0.2, 0.160, 0.298, 1.0);
    // float4 c = float4(0, 0, 0, 0);
    // float4 a = float4(0.976, 0.913, 0.764, 1.0);
    // float4 b = float4(0.952, 0.760, 0.286, 1.0);
    // float4 c = float4(1, 0.788, 0.278, 0);
	// return lerp(lerp(lerp(bg, a, t.x), b, t.y), c, t.z);
	return lerp(lerp(lerp(bgColor, teamColorA, t.x), teamColorB, t.y), teamColorC, t.z);
	// return lerp(lerp(lerp(a, b, t.x), c, t.y), d, t.z);
}

struct Agent {
    float2 position;
    float angle;
	int4 speciesMaskAndTrailType;
};

RWTexture2D<float4> TrailMap;
RWTexture2D<float> ObstructionMap;
// X = Red Home, Y = Green Home, Z = Blue Home, W = Food
RWTexture2D<float4> HomeFoodTrailMap;
RWTexture2D<float4> PlayerMap;
RWStructuredBuffer<Agent> agents;

float sense(Agent agent, float sensorAngleOffset) {
	float sensorAngle = agent.angle + sensorAngleOffset;
	float2 sensorDir = float2(cos(sensorAngle), sin(sensorAngle));

	float2 sensorPos = agent.position + sensorDir * float(3);
	int sensorCentreX = (int) sensorPos.x;
	int sensorCentreY = (int) sensorPos.y;

	float sum = 0;
    float sensorSize = 2;

	// Default, food-seeking. W is food trails
	//int4 senseWeight = int4(0, 0, 0, 1);
	//senseWeight.w = 1;
	////When holding, follow species trail home.
	//if (agent.speciesMaskAndTrailType.w == 1) {
	//	senseWeight = agent.speciesMaskAndTrailType * 2 - 1;
	//	senseWeight.w = 0;
	//}
	int4 senseWeight = agent.speciesMaskAndTrailType * 2 - 1;

	for (int offsetX = -sensorSize; offsetX <= sensorSize; offsetX ++) {
		for (int offsetY = -sensorSize; offsetY <= sensorSize; offsetY ++) {
			int sampleX = min(width - 1, max(0, sensorCentreX + offsetX));
			int sampleY = min(height - 1, max(0, sensorCentreY + offsetY));
			sum += dot(senseWeight, TrailMap[int2(sampleX,sampleY)]);
		}
	}

	return sum;
}

float GetObstructed(float2 position){
	return ObstructionMap[position];
}

int2 manhattan(int2 a, int2 b){
	return abs(b.x - a.x) + abs(b.y - a.y);
}

[numthreads(16, 1, 1)]
void UpdateAgents(uint3 id : SV_DispatchThreadID){
    if(id.x >= numAgents) { return; }

    Agent agent = agents[id.x];
	uint random = hash(agent.position.y * width + agent.position.x + hash(id.x + time * 100000));

    float sensorAngleRad = 30 * (3.1415 / 180);
	float weightForward = sense(agent, 0);
	float weightLeft = sense(agent, sensorAngleRad);
	float weightRight = sense(agent, -sensorAngleRad);
    float randomSteerStrength = scaleToRange01(random);
	float turnSpeed = turnFactor * 2 * 3.1415;
	float oldAngle = agent.angle;
	int holdingObstruction = agent.speciesMaskAndTrailType.w;

	//Continue at current angle if inside obstruction
	//if(GetObstructed(int2(agent.position.xy)) > 0){ }
    // Continue in same direction
	if (weightForward > weightLeft && weightForward > weightRight) {
		agents[id.x].angle += 0;
	}
	else if (weightForward < weightLeft && weightForward < weightRight) {
		agents[id.x].angle += (randomSteerStrength - 0.5) * 2 * turnSpeed * deltaTime;
	}
	// Turn right
	else if (weightRight > weightLeft) {
		agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
	}
	// Turn left
	else if (weightLeft > weightRight) {
		agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
	}

    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + direction * moveSpeed * deltaTime;


	int2 center = int2(width / 2, height / 2);
	int manhattanX = manhattan((int2)newPos, redHome.xy);
	int manhattanY = manhattan((int2)newPos, greenHome.xy);
	int manhattanZ = manhattan((int2)newPos, blueHome.xy);
	if(GetObstructed(int2(agent.position.xy)) == 0 && GetObstructed(int2(newPos)) > 0){
		if(!holdingObstruction){
			random = hash(random);
			if(scaleToRange01(random) < 1 && ObstructionMap[int2(newPos)] > 0){
				if (agents[id.x].speciesMaskAndTrailType.x > 0 && manhattanX > redHome.z) {
					ObstructionMap[int2(newPos)] = 0;
					agents[id.x].speciesMaskAndTrailType.w = 1;
				}
				else if (agents[id.x].speciesMaskAndTrailType.y > 0 && manhattanY > greenHome.z) {
					ObstructionMap[int2(newPos)] = 0;
					agents[id.x].speciesMaskAndTrailType.w = 1;
				}
				else if (agents[id.x].speciesMaskAndTrailType.z > 0 && manhattanZ > blueHome.z) {
					ObstructionMap[int2(newPos)] = 0;
					agents[id.x].speciesMaskAndTrailType.w = 1;
				}
				
			}
		} 
			//If attempt to enter obstruction, reset to previous position and pick new direction.
			random = hash(random);
			float randomAngle = scaleToRange01(random) * 2 * 3.1415;

			newPos = agent.position;
			agents[id.x].angle = randomAngle;
	} else {
		if(holdingObstruction && ObstructionMap[int2(newPos)] == 0 && (PlayerMap[int2(newPos)].x == 0 && PlayerMap[int2(newPos)].y == 0 && PlayerMap[int2(newPos)].z == 0)){
			random = hash(random);
			if(scaleToRange01(random) < 1){
				if(agents[id.x].speciesMaskAndTrailType.x > 0 && manhattanX < redHome.z){
					ObstructionMap[int2(newPos)] = 1;
					agents[id.x].speciesMaskAndTrailType.w = 0;
				} else if(agents[id.x].speciesMaskAndTrailType.y > 0 && manhattanY < greenHome.z){
					ObstructionMap[int2(newPos)] = 1;
					agents[id.x].speciesMaskAndTrailType.w = 0;
				} else if(agents[id.x].speciesMaskAndTrailType.z > 0 && manhattanZ < blueHome.z){
					ObstructionMap[int2(newPos)] = 1;
					agents[id.x].speciesMaskAndTrailType.w = 0;
				}
			}
		}
	}

	

	// Agent collission
	// else if(PlayerMap[int2(newPos)].x > 0 || PlayerMap[int2(newPos)].y || PlayerMap[int2(newPos)].z){
	// 	newPos = agent.position;
	// }
	

    // Clamp position to map boundaries, and pick new random move dir if hit boundary
	if (newPos.x < 0 || newPos.x >= (uint)width || newPos.y < 0 || newPos.y >= (uint)height) {
		random = hash(random);
		float randomAngle = scaleToRange01(random) * 2 * 3.1415;

		newPos.x = min(width-1,max(0, newPos.x));
		newPos.y = min(height-1,max(0, newPos.y));
		agents[id.x].angle = randomAngle;
	} else {
		float4 oldTrail = TrailMap[int2(newPos)];
		int4 trailType = agents[id.x].speciesMaskAndTrailType;
		//int4 trailType = agents[id.x].speciesMaskAndTrailType;
		//trailType.w = 0;
		////If Holding
		//if(agents[id.x].speciesMaskAndTrailType.w != 0){
		//	trailType = int4(0, 0, 0, 1);
		//	trailType.w = 1;
		//}
    	TrailMap[int2(newPos)] = min(1, oldTrail + trailType * deltaTime);
	}

    agents[id.x].position = newPos;
	PlayerMap[agents[id.x].position.xy] = agent.speciesMaskAndTrailType;
}

// kernel 2
#pragma kernel Diffuse

float decayRate;
float diffuseRate;
RWTexture2D<float4> DiffusedTrailMap;

[numthreads(8,8,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

	float4 sum = 0;
	float4 originalCol = TrailMap[id.xy];
	// 3x3 blur
	for (int offsetX = -1; offsetX <= 1; offsetX ++) {
		for (int offsetY = -1; offsetY <= 1; offsetY ++) {
			int sampleX = min(width-1, max(0, id.x + offsetX));
			int sampleY = min(height-1, max(0, id.y + offsetY));
			sum += TrailMap[int2(sampleX,sampleY)];
		}
	}

	float4 blurredCol = sum / 9;
	float diffuseWeight = saturate(diffuseRate * deltaTime);
	blurredCol = originalCol * (1 - diffuseWeight) + blurredCol * (diffuseWeight);

	//DiffusedTrailMap[id.xy] = blurredCol * saturate(1 - decayRate * deltaTime);
	DiffusedTrailMap[id.xy] = max(0, blurredCol - decayRate * deltaTime);
}

// kernel 3
#pragma kernel ColorMap

RWTexture2D<float4> Result;
[numthreads(8,8,1)]
void ColorMap (uint3 id : SV_DispatchThreadID){
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    Result[id.xy] = ColorLerp(TrailMap[id.xy]);
}

// kernel 4
#pragma kernel ObstructionGeneration

[numthreads(8,8,1)]
void ObstructionGeneration (uint3 id : SV_DispatchThreadID){
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

	float manhattan = abs((width / 2.0) + 200 - id.x) + abs((height / 2.0) - id.y);
	if (manhattan < 100)
		ObstructionMap[id.xy] = 0; //1;
	else ObstructionMap[id.xy] = 0;
}
