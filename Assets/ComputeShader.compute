// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateAgents
uint width;
uint height;
uint numAgents;
float deltaTime;
float time;

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

float4 ColorLerp(float t){
    float4 a = float4(0.776, 0.784, 0.984, 1);
    float4 b = float4(0.2, 0.160, 0.298, 1.0);
    float4 c = float4(0, 0, 0, 0);
    // float4 a = float4(0.976, 0.913, 0.764, 1.0);
    // float4 b = float4(0.952, 0.760, 0.286, 1.0);
    // float4 c = float4(1, 0.788, 0.278, 0);
    return lerp(lerp(c, a, t), b, 1-t);
}

struct Agent {
    float2 position;
    float angle;
};

RWTexture2D<float4> TrailMap;
RWStructuredBuffer<Agent> agents;

float sense(Agent agent, float sensorAngleOffset) {
	float sensorAngle = agent.angle + sensorAngleOffset;
	float2 sensorDir = float2(cos(sensorAngle), sin(sensorAngle));

	float2 sensorPos = agent.position + sensorDir * float(3);
	int sensorCentreX = (int) sensorPos.x;
	int sensorCentreY = (int) sensorPos.y;

	float sum = 0;
    float sensorSize = 2;

	int4 senseWeight = int4(1, 1, 1, 1);

	for (int offsetX = -sensorSize; offsetX <= sensorSize; offsetX ++) {
		for (int offsetY = -sensorSize; offsetY <= sensorSize; offsetY ++) {
			int sampleX = min(width - 1, max(0, sensorCentreX + offsetX));
			int sampleY = min(height - 1, max(0, sensorCentreY + offsetY));
			sum += dot(senseWeight, TrailMap[int2(sampleX,sampleY)]);
		}
	}

	return sum;
}

[numthreads(16, 1, 1)]
void UpdateAgents(uint3 id : SV_DispatchThreadID){
    if(id.x >= numAgents) { return; }

    Agent agent = agents[id.x];
	uint random = hash(agent.position.y * width + agent.position.x + hash(id.x + time * 100000));

    float sensorAngleRad = 30 * (3.1415 / 180);
	float weightForward = sense(agent, 0);
	float weightLeft = sense(agent, sensorAngleRad);
	float weightRight = sense(agent, -sensorAngleRad);
    float randomSteerStrength = scaleToRange01(random);
	float turnSpeed = float(0.5f) * 2 * 3.1415;

    // Continue in same direction
	if (weightForward > weightLeft && weightForward > weightRight) {
		agents[id.x].angle += 0;
	}
	else if (weightForward < weightLeft && weightForward < weightRight) {
		agents[id.x].angle += (randomSteerStrength - 0.5) * 2 * turnSpeed * deltaTime;
	}
	// Turn right
	else if (weightRight > weightLeft) {
		agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
	}
	// Turn left
	else if (weightLeft > weightRight) {
		agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
	}

    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + direction * float(2) * deltaTime;

    // Clamp position to map boundaries, and pick new random move dir if hit boundary
	if (newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height) {
		random = hash(random);
		float randomAngle = scaleToRange01(random) * 2 * 3.1415;

		newPos.x = min(width-1,max(0, newPos.x));
		newPos.y = min(height-1,max(0, newPos.y));
		agents[id.x].angle = randomAngle;
	}

    agents[id.x].position = newPos;
    TrailMap[int2(newPos.x, newPos.y)] = 1;
}

#pragma kernel Diffuse

float decayRate;
float diffuseRate;
RWTexture2D<float4> DiffusedTrailMap;

[numthreads(8,8,1)]
void Diffuse (uint3 id : SV_DispatchThreadID)
{
	if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

	float4 sum = 0;
	float4 originalCol = TrailMap[id.xy];
	// 3x3 blur
	for (int offsetX = -1; offsetX <= 1; offsetX ++) {
		for (int offsetY = -1; offsetY <= 1; offsetY ++) {
			int sampleX = min(width-1, max(0, id.x + offsetX));
			int sampleY = min(height-1, max(0, id.y + offsetY));
			sum += TrailMap[int2(sampleX,sampleY)];
		}
	}

	float4 blurredCol = sum / 9;
	float diffuseWeight = saturate(diffuseRate * deltaTime);
	blurredCol = originalCol * (1 - diffuseWeight) + blurredCol * (diffuseWeight);

	//DiffusedTrailMap[id.xy] = blurredCol * saturate(1 - decayRate * deltaTime);
	DiffusedTrailMap[id.xy] = max(0, blurredCol - decayRate * deltaTime);
}

#pragma kernel ColorMap

RWTexture2D<float4> Result;
[numthreads(8,8,1)]
void ColorMap (uint3 id : SV_DispatchThreadID){
    if (id.x < 0 || id.x >= (uint)width || id.y < 0 || id.y >= (uint)height) {
		return;
	}

    Result[id.xy] = ColorLerp(TrailMap[id.xy].w);
}
